{{ ansible_managed | comment }}

{% set oh_my_zsh = user.oh_my_zsh|default({}) %}

# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:/usr/local/bin:$PATH

# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time oh-my-zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="{{ oh_my_zsh.theme | default(oh_my_zsh_theme) }}"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

{% if 'auto' == oh_my_zsh.update_mode | default(oh_my_zsh_update_mode) %}
# Update automatically without asking
zstyle ':omz:update' mode auto
{% elif 'reminder' == oh_my_zsh.update_mode | default(oh_my_zsh_update_mode) %}
# Just remind me to update when it's time
zstyle ':omz:update' mode reminder
{% else %}
# Disable automatic updates
zstyle ':omz:update' mode disabled
{% endif %}

# How often to auto-update (in days).
{% if 'disabled' != oh_my_zsh.update_mode | default(oh_my_zsh_update_mode) %}
zstyle ':omz:update' frequency {{ oh_my_zsh.update_frequency | default(oh_my_zsh_update_frequency) }}
{% else %}
# zstyle ':omz:update' frequency {{ oh_my_zsh.update_frequency | default(oh_my_zsh_update_frequency) }}
{% endif %}

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=({{ oh_my_zsh.plugins | default(oh_my_zsh_plugins) | join(' ') }})

source $ZSH/oh-my-zsh.sh

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"


# ==============================================================================
# Docker Swarm Utility Functions for Zsh (Complete Version)
# ==============================================================================

# Lista todas as labels de todos os nodes de forma bonita
swarm-labels() {
    echo "üê≥ Docker Swarm - Node Labels\n"
    docker node ls -q | xargs -I {} docker node inspect {} --format '{{json .}}' | jq -r '
    "‚ï≠‚îÄ üñ•Ô∏è  " + .Description.Hostname + " [" + (.Spec.Role | ascii_upcase) + "]" + 
    (if .Status.State == "ready" then " ‚úÖ" else " ‚ùå" end) +
    (if (.Spec.Labels // {} | length) > 0 then
      "\n‚îú‚îÄ üè∑Ô∏è  Labels:" +
      "\n" + ((.Spec.Labels // {}) | to_entries | map("‚îÇ  ‚Ä¢ \(.key): \(.value)") | join("\n"))
    else
      "\n‚îú‚îÄ üìù No custom labels"
    end) +
    "\n‚ï∞‚îÄ " + ("‚îÄ" * 50) + "\n"'
}

# Lista labels em formato JSON estruturado
swarm-labels-json() {
    echo "üê≥ Docker Swarm - Node Labels (JSON Format)\n"
    docker node ls -q | xargs -I {} docker node inspect {} --format '{{json .}}' | jq -s '
    map({
      "hostname": .Description.Hostname,
      "role": .Spec.Role,
      "status": .Status.State,
      "availability": .Spec.Availability,
      "labels": (.Spec.Labels // {}),
      "address": .Status.Addr,
      "engine_version": .Description.Engine.EngineVersion
    }) | sort_by(.hostname)'
}

# Lista apenas labels que come√ßam com 'node.'
swarm-node-labels() {
    echo "üê≥ Docker Swarm - Node.* Labels Only\n"
    docker node ls -q | xargs -I {} docker node inspect {} --format '{{json .}}' | jq -r '
    .Description.Hostname as $hostname |
    (.Spec.Labels // {}) | 
    with_entries(select(.key | startswith("node."))) |
    if length > 0 then
      "üñ•Ô∏è  \($hostname):\n" + (to_entries | map("   \(.key): \(.value)") | join("\n")) + "\n"
    else
      "üñ•Ô∏è  \($hostname): (no node.* labels)\n"
    end'
}

# Vis√£o geral do cluster Swarm
swarm-overview() {
    echo "üê≥ Docker Swarm Cluster Overview\n"
    echo "üìä Nodes:"
    docker node ls
    echo "\nüìã Services:"
    docker service ls
    echo "\nüì¶ Stacks:"
    docker stack ls 2>/dev/null || echo "   No stacks deployed"
    echo "\nüîç System Info:"
    docker system df
}

# Lista todos os servi√ßos com seus constraints
swarm-services() {
    echo "üê≥ Docker Swarm - Services & Constraints\n"
    docker service ls --format "table {{.ID}}\t{{.Name}}\t{{.Mode}}\t{{.Replicas}}\t{{.Image}}" | head -1
    for service in $(docker service ls --format "{{.Name}}"); do
        constraints=$(docker service inspect $service --format '{{range .Spec.TaskTemplate.Placement.Constraints}}{{.}} {{end}}' 2>/dev/null)
        replicas=$(docker service inspect $service --format '{{.Spec.Replicas}}' 2>/dev/null)
        mode=$(docker service inspect $service --format '{{.Spec.Mode}}' 2>/dev/null)
        image=$(docker service inspect $service --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null | cut -d'@' -f1)
        
        printf "%-12s %-20s %-10s %-8s %s\n" \
            "$(docker service ls --filter name=$service --format '{{.ID}}')" \
            "$service" \
            "$mode" \
            "$replicas" \
            "$image"
        
        if [ -n "$constraints" ]; then
            echo "   üéØ Constraints: $constraints"
        fi
    done
}

# Mostra onde cada servi√ßo est√° rodando
swarm-placement() {
    echo "üê≥ Docker Swarm - Service Placement\n"
    for service in $(docker service ls --format "{{.Name}}"); do
        echo "üì¶ Service: $service"
        docker service ps $service --format "table {{.Name}}\t{{.Node}}\t{{.CurrentState}}\t{{.DesiredState}}" | tail -n +2 | while read line; do
            echo "   $line"
        done
        echo ""
    done
}

# Adiciona labels a um node
swarm-label-add() {
    if [ $# -lt 3 ]; then
        echo "Uso: swarm-label-add <node-name> <label-key> <label-value>"
        echo "Exemplo: swarm-label-add worker01 node.type database"
        return 1
    fi
    
    local node=$1
    local key=$2
    local value=$3
    
    echo "üè∑Ô∏è  Adicionando label '$key=$value' ao node '$node'..."
    docker node update --label-add $key=$value $node
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Label adicionada com sucesso!"
        echo "üîç Labels atuais do node '$node':"
        docker node inspect $node --format '{{json .Spec.Labels}}' | jq -r 'to_entries | map("   \(.key): \(.value)") | join("\n")'
    else
        echo "‚ùå Erro ao adicionar label"
    fi
}

# Remove labels de um node
swarm-label-rm() {
    if [ $# -lt 2 ]; then
        echo "Uso: swarm-label-rm <node-name> <label-key1> [label-key2] ..."
        echo "Exemplo: swarm-label-rm worker01 node.type node.dc"
        return 1
    fi
    
    local node=$1
    shift
    
    echo "üóëÔ∏è  Removendo labels do node '$node'..."
    for label in "$@"; do
        echo "   Removendo: $label"
        docker node update --label-rm $label $node 2>/dev/null
        if [ $? -eq 0 ]; then
            echo "   ‚úÖ $label removida"
        else
            echo "   ‚ö†Ô∏è  $label n√£o encontrada"
        fi
    done
}

# Remove TODAS as labels node.* de TODOS os nodes
swarm-clean-node-labels() {
    echo "‚ö†Ô∏è  ATEN√á√ÉO: Isso remover√° TODAS as labels 'node.*' de TODOS os nodes!"
    echo "Nodes afetados:"
    docker node ls --format "   ‚Ä¢ {{.Hostname}} ({{.Status}})"
    echo ""
    
    vared -p "Digite 'CONFIRMAR' para continuar: " confirm
    
    if [ "$confirm" = "CONFIRMAR" ]; then
        echo "üóëÔ∏è  Removendo todas as labels node.* ..."
        docker node ls -q | while read node; do
            hostname=$(docker node inspect $node --format '{{.Description.Hostname}}')
            echo "   Limpando node: $hostname"
            
            # Lista todas as labels que come√ßam com 'node.' e remove
            docker node inspect $node --format '{{json .Spec.Labels}}' | jq -r 'keys[]' | grep '^node\.' | while read label; do
                docker node update --label-rm $label $node >/dev/null 2>&1
            done
        done
        echo "‚úÖ Limpeza conclu√≠da!"
    else
        echo "‚ùå Opera√ß√£o cancelada."
    fi
}

# Mostra logs de um servi√ßo
swarm-logs() {
    if [ $# -lt 1 ]; then
        echo "Uso: swarm-logs <service-name> [--follow]"
        echo "Exemplo: swarm-logs nginx --follow"
        return 1
    fi
    
    local service=$1
    local follow_flag=""
    
    if [ "$2" = "--follow" ] || [ "$2" = "-f" ]; then
        follow_flag="--follow"
    fi
    
    echo "üìú Logs do servi√ßo: $service"
    docker service logs $follow_flag $service
}

# Escala um servi√ßo
swarm-scale() {
    if [ $# -ne 2 ]; then
        echo "Uso: swarm-scale <service-name> <replicas>"
        echo "Exemplo: swarm-scale nginx 3"
        return 1
    fi
    
    local service=$1
    local replicas=$2
    
    echo "üìà Escalando servi√ßo '$service' para $replicas r√©plicas..."
    docker service scale $service=$replicas
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Servi√ßo escalado com sucesso!"
        echo "üìä Status atual:"
        docker service ps $service --format "table {{.Name}}\t{{.Node}}\t{{.CurrentState}}"
    fi
}

# Drena um node (coloca em maintenance)
swarm-drain() {
    if [ $# -ne 1 ]; then
        echo "Uso: swarm-drain <node-name>"
        echo "Exemplo: swarm-drain worker01"
        return 1
    fi
    
    local node=$1
    
    echo "üö´ Drenando node '$node' (colocando em maintenance)..."
    echo "üì¶ Servi√ßos atualmente rodando no node:"
    docker node ps $node --format "   ‚Ä¢ {{.Name}} ({{.CurrentState}})"
    echo ""
    
    vared -p "Continuar? (y/N): " confirm
    
    if [[ $confirm =~ ^[Yy]$ ]]; then
        docker node update --availability drain $node
        echo "‚úÖ Node '$node' foi drenado. Monitorando realoca√ß√£o..."
        sleep 3
        docker node ps $node
    else
        echo "‚ùå Opera√ß√£o cancelada."
    fi
}

# Reativa um node
swarm-activate() {
    if [ $# -ne 1 ]; then
        echo "Uso: swarm-activate <node-name>"
        echo "Exemplo: swarm-activate worker01"
        return 1
    fi
    
    local node=$1
    
    echo "‚úÖ Reativando node '$node'..."
    docker node update --availability active $node
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Node '$node' foi reativado!"
        docker node ls --filter "name=$node"
    fi
}

# Monitoramento em tempo real do cluster
swarm-monitor() {
    echo "üîÑ Monitoramento em tempo real do Swarm (Ctrl+C para sair)"
    echo "Atualizando a cada 5 segundos..."
    echo ""
    
    while true; do
        clear
        echo "üê≥ Docker Swarm - Monitor $(date '+%H:%M:%S')"
        echo "============================================================"
        
        echo "\nüìä NODES:"
        docker node ls
        
        echo "\nüìã SERVICES:"
        docker service ls
        
        echo "\nüîç TASKS:"
        docker service ps $(docker service ls --format "{{.Name}}") --format "table {{.Name}}\t{{.Node}}\t{{.CurrentState}}\t{{.Error}}" 2>/dev/null | head -20
        
        sleep 5
    done
}

# Backup das configura√ß√µes do Swarm
swarm-backup() {
    local backup_dir="swarm-backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p $backup_dir
    
    echo "üíæ Criando backup do Swarm em: $backup_dir"
    
    # Nodes e labels
    echo "üìù Exportando nodes e labels..."
    docker node ls -q | xargs -I {} docker node inspect {} > $backup_dir/nodes.json
    
    # Services
    echo "üìù Exportando services..."
    docker service ls -q | xargs -I {} docker service inspect {} > $backup_dir/services.json
    
    # Networks
    echo "üìù Exportando networks..."
    docker network ls --filter driver=overlay -q | xargs -I {} docker network inspect {} > $backup_dir/networks.json
    
    # Secrets (apenas metadados)
    echo "üìù Exportando secrets metadata..."
    docker secret ls -q | xargs -I {} docker secret inspect {} > $backup_dir/secrets.json 2>/dev/null || echo "[]" > $backup_dir/secrets.json
    
    # Configs
    echo "üìù Exportando configs..."
    docker config ls -q | xargs -I {} docker config inspect {} > $backup_dir/configs.json 2>/dev/null || echo "[]" > $backup_dir/configs.json
    
    # Info do cluster
    echo "üìù Exportando info do cluster..."
    docker info > $backup_dir/cluster-info.txt
    
    echo "‚úÖ Backup conclu√≠do em: $backup_dir"
    echo "üìÅ Arquivos criados:"
    ls -la $backup_dir/
}

# Deploy r√°pido de um servi√ßo com constraints
swarm-deploy() {
    if [ $# -lt 2 ]; then
        echo "Uso: swarm-deploy <service-name> <image> [constraint1] [constraint2] ..."
        echo "Exemplo: swarm-deploy nginx nginx:latest 'node.labels.node.type==application'"
        return 1
    fi
    
    local service_name=$1
    local image=$2
    shift 2
    
    local constraints=""
    for constraint in "$@"; do
        constraints="$constraints --constraint '$constraint'"
    done
    
    echo "üöÄ Deploying service '$service_name' with image '$image'..."
    if [ -n "$constraints" ]; then
        echo "üéØ Constraints: $constraints"
    fi
    
    eval "docker service create --name $service_name $constraints $image"
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Servi√ßo '$service_name' deployado com sucesso!"
        echo "üìä Status:"
        docker service ps $service_name
    else
        echo "‚ùå Erro no deploy do servi√ßo"
    fi
}

# For√ßa redistribui√ß√£o de um servi√ßo
swarm-redeploy() {
    if [ $# -ne 1 ]; then
        echo "Uso: swarm-redeploy <service-name>"
        echo "Exemplo: swarm-redeploy nginx"
        return 1
    fi
    
    local service=$1
    
    echo "üîÑ For√ßando redesploy do servi√ßo '$service'..."
    docker service update --force $service
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Redeploy iniciado com sucesso!"
        echo "üìä Monitorando tasks..."
        sleep 2
        docker service ps $service
    else
        echo "‚ùå Erro no redeploy"
    fi
}

# Lista de recursos do cluster por node
swarm-resources() {
    echo "üê≥ Docker Swarm - Node Resources\n"
    for node in $(docker node ls --format "{{.Hostname}}"); do
        echo "üñ•Ô∏è  NODE: $node"
        
        # Usa docker node inspect para pegar informa√ß√µes de recursos
        docker node inspect $node --format '
        üìä CPU: {{.Description.Resources.NanoCPUs}} nano CPUs
        üíæ RAM: {{.Description.Resources.MemoryBytes}} bytes
        üè∑Ô∏è  Platform: {{.Description.Platform.OS}}/{{.Description.Platform.Architecture}}
        üê≥ Engine: {{.Description.Engine.EngineVersion}}
        üìç Address: {{.Status.Addr}}
        ' 2>/dev/null
        
        echo "üì¶ Running tasks:"
        docker node ps $node --format "   ‚Ä¢ {{.Name}} ({{.CurrentState}})" | head -5
        echo ""
    done
}

# Lista aliases das fun√ß√µes
swarm-help() {
    echo "üê≥ Docker Swarm Functions - Help\n"
    echo "üìã Available Commands:"
    echo "   swarm-labels           - Lista labels de todos os nodes (visual)"
    echo "   swarm-labels-json      - Lista labels em formato JSON"
    echo "   swarm-node-labels      - Lista apenas labels 'node.*'"
    echo "   swarm-overview         - Vis√£o geral do cluster"
    echo "   swarm-services         - Lista servi√ßos com constraints"
    echo "   swarm-placement        - Mostra onde cada servi√ßo est√° rodando"
    echo "   swarm-label-add        - Adiciona label a um node"
    echo "   swarm-label-rm         - Remove labels de um node"
    echo "   swarm-clean-node-labels- Remove TODAS as labels 'node.*'"
    echo "   swarm-logs             - Mostra logs de um servi√ßo"
    echo "   swarm-scale            - Escala um servi√ßo"
    echo "   swarm-drain            - Drena um node (maintenance)"
    echo "   swarm-activate         - Reativa um node"
    echo "   swarm-monitor          - Monitor em tempo real"
    echo "   swarm-backup           - Backup das configura√ß√µes"
    echo "   swarm-deploy           - Deploy r√°pido com constraints"
    echo "   swarm-redeploy         - For√ßa redeploy de um servi√ßo"
    echo "   swarm-resources        - Lista recursos de cada node"
    echo "   swarm-help             - Mostra esta ajuda"
    echo ""
    echo "üí° Tip: Use 'swarm-' + TAB para autocompletar"
}

# Aliases √∫teis
alias sw='swarm-overview'
alias swl='swarm-labels'
alias sws='swarm-services'
alias swp='swarm-placement'
alias swm='swarm-monitor'
alias swr='swarm-resources'

# Autocompletar para zsh
_swarm_commands=(
    'swarm-labels:Lista labels de todos os nodes (visual)'
    'swarm-labels-json:Lista labels em formato JSON'
    'swarm-node-labels:Lista apenas labels node.*'
    'swarm-overview:Vis√£o geral do cluster'
    'swarm-services:Lista servi√ßos com constraints'
    'swarm-placement:Mostra onde cada servi√ßo est√° rodando'
    'swarm-label-add:Adiciona label a um node'
    'swarm-label-rm:Remove labels de um node'
    'swarm-clean-node-labels:Remove TODAS as labels node.*'
    'swarm-logs:Mostra logs de um servi√ßo'
    'swarm-scale:Escala um servi√ßo'
    'swarm-drain:Drena um node (maintenance)'
    'swarm-activate:Reativa um node'
    'swarm-monitor:Monitor em tempo real'
    'swarm-backup:Backup das configura√ß√µes'
    'swarm-deploy:Deploy r√°pido com constraints'
    'swarm-redeploy:For√ßa redeploy de um servi√ßo'
    'swarm-resources:Lista recursos de cada node'
    'swarm-help:Mostra esta ajuda'
)

_swarm_completion() {
    _describe 'swarm commands' _swarm_commands
}

# Registra o autocompletar para fun√ß√µes que come√ßam com swarm-
compdef _swarm_completion swarm-labels
compdef _swarm_completion swarm-labels-json
compdef _swarm_completion swarm-node-labels
compdef _swarm_completion swarm-overview
compdef _swarm_completion swarm-services
compdef _swarm_completion swarm-placement
compdef _swarm_completion swarm-label-add
compdef _swarm_completion swarm-label-rm
compdef _swarm_completion swarm-clean-node-labels
compdef _swarm_completion swarm-logs
compdef _swarm_completion swarm-scale
compdef _swarm_completion swarm-drain
compdef _swarm_completion swarm-activate
compdef _swarm_completion swarm-monitor
compdef _swarm_completion swarm-backup
compdef _swarm_completion swarm-deploy
compdef _swarm_completion swarm-redeploy
compdef _swarm_completion swarm-resources
compdef _swarm_completion swarm-help